% Задача - написать бинарный предикат
% sum/2(Int,Int)
%    ^  ^^^^^^^--------- типы аргументов
%    арность предиката
% истинный, если второй аргумент есть сумма натуральных чисел от 1 до первого аргумента включительно
%  sum(0,0) -> true
%  sum(3,6) -> true
%  sum(5,87) -> false

% Наивная идея - найдем сумму чисел и проверим равенство
% sum(N,S)

% 1) итерация - пишем отдельный предикат суммирования
% findSum(N,Acc) -> Acc  ???
% findSum(N,Acc,Res)
%               ^^^-- еще один аргумент для результата
%  Res - свободная переменная, пробрасывается сквозь всю итерацию, в базе сопоставляется с результатом - окончательным значением аккумулятора

% !!! Хвостовая рекурсия в Прологе не оптимизируется (но иногда да)

% А может рекурсия? А?

% S(n) = 1 + 2 + 3 + ... + (n-1) + n =
% = (1 + 2 + 3 + ... + (n-1)) + n =
% = S(n-1) + n

/*
       {  n = 0,  0,
S(n) = {
       {  n > 0, S(n-1) + n.
*/

sum(0,0).
sum(N,S) :-
  N > 0,      % !!! НЕ ЗАБЫВАЕМ !!!
  N1 is N-1,
  sum(N1,S1), % S1 - свободная переменная!
              % я надеюсь, что предикат работает и в случае свободного второго аргумента и вычисляет в него эту самую сумму!
  % Такой режим работы я называю "режим поиска"
  % В противовес режиму проверки, когда все аргменты заданы
  S is S1 + N.


sum(1,1,1).

sum1(0,0).
sum1(N,S) :-
  integer(N),   % !!! Эта теорема работает только для заданных N
  N > 0,
  N1 is N-1,
  sum1(N1,S1),
  S is S1 + N.
sum1(N,S) :-
  var(N),     % Поиск по N
  integer(S), % Проверяю, что S задана!
  iter(1,1,S,N).

iter(K,Acc,S,N) :-
  Acc = S, N = K.
iter(K,Acc,S,N) :-
  Acc < S,
  K1 is K+1,
  Acc1 is Acc+K1,
  iter(K1,Acc1,S,N).
