% Пролог - встроенный поиск в глубину
% Всякая задача с поиском в глубину может быть попробована решена Прологом
% В частности поиск пути в графе

% Мужик, капуста, коза и волк - переправа
% 2-местная лодка: мужик + что-нибудь одно
% Нельзя оставить козу наедине с капустой
% Нельзя оставить волка наедине с козой
% Как организовать переезд?

% Какова графовая формализация данной задачи?
% Вершина - распределение объектов по берегам
% Две вергины связаны ребром, если одно стостяние может быть получено из другого одним перевозом

% Значение переменной того или иного объекта = left или right в зависимости от берега, на котором расположен объект

%  Для проверки/вычисления противоположности берегов
opposite(left,right).
opposite(right,left).

% state(P, C, G, W) - состояние переправы
%  P(easant) - берег, на котором мужик
%  C(abbige) - берег, на котором капста
%  G(oat)    - --"-- коза
%  W(olf)    - --"-- волк

%  move - проверка, что два состояния смежны

% Два состояния, отличающиеся положением мужика, инциденты
% Я описал переезд одного мужика без второго объекта
move(state(P1, C, G, W), state(P2, C, G, W)) :-
    opposite(P1,P2).

% переезд мужика с капустой
move(state(P1, C1, G, W), state(P2, C2, G, W)) :-
    P1 = C1, P2 = C2,
    opposite(P1,P2).

% переезд мужика с козой
move(state(P1, C, G1, W), state(P2, C, G2, W)) :-
    P1 = G1, P2 = G2,
    opposite(P1,P2).

% переезд мужика с волком
move(state(P1, C, G, W1), state(P2, C, G, W2)) :-
    P1 = W1, P2 = W2,
    opposite(P1,P2).

% Проверка небезопасности состояния
unsafe(state(P, C, G, _)) :-
    opposite(P,C), G = C.
unsafe(state(P, _, G, W)) :-
    opposite(P,W), G = W.

solve(Path) :-
  CurState = state(left, left, left, left),
    % текущее состояние - все на левом берегу
  TargetState = state(right, right, right, right),
  dfs(CurState, TargetState, [CurState], Path).

% dfs:
%   1 - текущее состояние
%   2 - целевое состояние
%   3 - пройденные состояния (список)
%   4 - переменная для выдачи результата

%  База рекурсии поиска в глубинуё
dfs(TargetState, TargetState, Path, Path).

%  Шаг рекурсии
dfs(CurState, TargetState, CurPath, Path) :-
  move(CurState, NewState),
    % поиск (перебор) соседей
  \+ unsafe(NewState),
    % проверка проверка, что вообще могу перейти
  \+ memberchk(NewState, CurPath),
    % проверка, что не прошел вершину раньше
  dfs(NewState, TargetState,
      [NewState|CurPath], Path).
    %  переход в новую вершину
